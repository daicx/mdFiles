---
title: 对象的回收和分配
date: 2019-03-17 13:56:47
tags: 
- GC算法
categories:
- jvm
- 对象的回收和分配
---

GC算法

2019年3月17日

12:32

# 简介:

由内存模型可知,虚拟机栈,本地方法栈,程序计数器都是线程私有的,伴随着线程的结束而消失.其中虚拟机栈和本地方法栈中的栈桢也会随着方法的进入和退出而进行着入栈和出栈的操作.每一个栈桢需要的内存基本上是在类结构确定下来后就确定了.因此内存的回收和分配都具有确定性,因此不需要过多考虑.但是在java堆和方法区,由于是动态加载,只有在运行期才会知道需要分配和回收的内存.因此,垃圾回收器所关注的也是这部分的内存.

# 判断对象已死?

要进行对象回收首先要确定对象是否已死,目前有以下几种方式:

## 1.    引用计数算法:

为每个对象添加一个引用计数器,每有一个地方引用,就加1,引用失效就减1.当为0时,则判为死亡.此方法在两个对象相互引用时,无法用此算法清除.

## 2.    根搜索算法:

通过一个GC root的根节点,往下搜索,如果搜索不到,则为死亡.

在java中,可作为GC roots的对象有:

a.     虚拟机栈中的栈桢下面的局部变量表所引用的对象.

b.    方法区中静态类属性所引用的对象.

c.    方法区中的常量所引用的对象.

d.    本地方法栈中native方法所引用的对象.

## 3.    java中的引用

a.    强引用:

例如:Object obj= new Object();只要引用还存在,永远不会GC.

b.    软引用:

用SoftReference类来实现,被软引用关联的对象,在内存溢出发生之前,会对这部分进行回收.

c.    弱引用

用WeakReference类实现,无论是否会发生内存溢出,在GC的时候,都会清除.

d.    虚引用

用PhantomReference类实现.唯一目的是在这些对象被回收之前,会得到一个系统通知,

## 4.    Finallize()方法

只会被系统调用一次,有不确定性,并且代价极大.建议用try-finally来代替.

# GC算法

## 1.    标记-清除法

首先标记出对象,然后统一回收.缺点是:效率低.并会产生大量不连续的内存碎片.

## 2.    复制法

将内存分为两块,每次讲需要回收的对象放到一块,然后统一清理.缺点是:活跃内存减少一半,代价极大.

## 3.    复制法进阶版

由于新生代对象具有极高的死亡率,因此将内存按照8:1的比例划分为一个大的Eden和2个小的survivor空间.每次使用的是Eden空间和一个survivor空间.在进行回收时,将或者的对象复制到那个暂时不用的survivor空间中.然后清理掉Eden空间和survivor空间.这样基本上只会浪费10%的内存空间.这种方式只适用于新生代.

## 4.    标记-整理算法

​	将或者的对象移动到一块,然后清理掉后面的对象.适用于老年代.

# 内存的分配策略:

## 1.    新生代的Eden区分配

大多数情况下,对象在新生代的Eden区分配,内存不足时,发起一次Minor GC

## 2.    大对象直接进入老年代.

需要注意的是,避免编写短命的大对象.

## 3.    长期存活的对象直接进入老年代.

每个对象都有一个年龄计数器(Age),在Eden出生,在第一次Minor GC下仍存活,并且被survivor所接受的话,就会移动到survivor中,年龄设为1.每次熬过一次Minor GC,年龄就加1,直到默认的15岁后,便会移动到老年代.

## 4.    动态对象年龄判断

如果13岁的对象所占的空间大于survivor空间的一般,则会吧13的也放到老年代.

## 5.    空间分配担保

当新生代在进行一个Minor GC后,仍有大量对象存活.将会将survivor空间无法容纳的对象直接进入老年代.在每次发生Minor GC 之前,都会检查之前每次晋升到老年代的平均大小,如果大于,便会改为一个Full GC.

 