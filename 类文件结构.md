---
title: jvm之类文件结构
date: 2019-03-04 22:33:42
tags:
- 字节码
- 字节码指令
categories:
- jvm
- jvm之类文件结构

---

# 1.1 机器码与字节码

①机器码(Native code): 可由CPU直接读取操作的机器指令.处于最底层,不需要编译.速度最快.不可跨平台.依靠硬件存在.

②字节码:是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。依靠平台存在.

以前用机器码操作系统，现在是用字节码操作机器码，进一步操作系统,使得语言跨平台成为可能.

# 1.2.跨平台原理:

java语言一如既往的保持着"一次编写,到处运行的特性",依靠的就是其JVM.JVM不关注语言的来源,只关注的是"CLASS 二进制文件",只要符合JVM的类的编写规范,就可以经过JVM进行字节码到机器码的转换.

![img](1.png)

 

因此,

功能性比较:

java或者其他语言>字节码>机器码

速度上:相反

# 1.3.class文件结构简介:

## 1.3.1.class内容格式

Class文件是一组以8位字节为单位的二进制流,各个数据项目以严格的顺序紧凑的排列在CLass文件中,中间没有分隔符.因此文件中的数据全是必要的数据.当遇到需要占用8个字节以上的数据时,则会按照高位在前的方式分割为若干个8位字节进行存储.

①.高位在前,高位字节在地址最低位

例如:32位下,int i=10

低位在前为:

00001010 00000000 00000000 00000000

而在高位优先的内存中：

00000000 00000000 00000000 00001010

字节码本身是无序的,需要有一定的规则去读取数据,高位优先更符合人的操作习惯,但是在X86处理器采用的是低位优先的规则.

## 1.3.2.class 结构

CLass文件中定义了类似于C语言的2种数据类型:无符号数和表.

①.无符号数是最基本的数据类型,用u1,u2,u4,u8分别表示1,2,3,8个字节.

②.表是由无符号数和表构成的复合数据类型.习惯性的以"_info"结尾.

因此Class文件本质上是由众多无符号数组成的一张表.

下面贴上一张结构组成图:

![img](2.png)

**因此,一个class里面会有1个4个字节的magic+1个2个字节的minor_version........组成.其中具体含义后续详细介绍.**

 

### 1.3.2.1 magic 魔数

在对一个文件进行类型判断时,比如是.png还是.jpg,文件存储标准中都会使用魔数来进行判断.同样,判断是否为一个class文件,也使用了这个标准.对于class文件,开头的前4个字节为魔数,值为:0XCAFEBABE,用来表示这是一个class文件.紧接着魔数后面的4个字节存储着class文件的版本号,5,6位次版本号,7,8是主版本号.高版本的JDK会向下兼容以前版本的class文件,但是会拒绝执行超过其版本的class文件,即使文件格式没有发生变化.

![img](3.png)

对一个class文件,用16进制编辑器打开,可以看到上面的结果.

第一行的0xCAFEBEBE为文件类型标志,5,6为0x0000次版本号,7,8为0x0032,十进制为50,表示可被1.6以上的jdk进行编译.下面是jdk和class文件版本对应表:

![img](4.png)

### 1.3.2.2 constant_pool (常量池)

紧接着主版本号之后,便是常量池的入口,可以把常量池比作class文件的资源仓库.这是文件中第一个表数据结构,由于常量的个数不固定,所以在常量池前面会有一个u2类型的数据,constant_pool_count来表示类中定义的常量池的个数.不过常量池会将索引为0的位置留作备用,用来满足指向常量池的索引值需要表示为"不引用任何常量池"的意思.因此常量池的实际个数为constant_pool_count-1.

常量池主要有2中结构:字面量和符号引用.

①.字面量:java语言层面的常量,如文本字符串,final声明的常量等.

②.符号引用:编译方面的概念,主要有类和接口的全限定名,字段的名称和描述符,方法的名称和描述符.

在C/C++,会经历编辑,编译,链接,运行阶段,但是java中没有链接这一阶段,而是采用的是在虚拟机加载类文件的时候动态连接.意思是class文件中不会保存方法字段的占用内存信息,只有在运行期间进行转换才会得到.这部分内容在类加载机制中会详细说明.

常量池中每一个常量都是一张表,开始的第一位是u1类型的标志位,对应关系如下:

![img](5.png)

每个常量又都会有各自的结构组成,

具体class字节码分析工具,可以用jdk下的bin目录下,javap工具,通过执行:

javap -verbose ttclass

​       可将class转化为字节码,输出.

### 1.3.2.3 访问标志

主要是用于标志一些类和接口层次的信息,占用2个字节

![img](6.png)

例如:一个普通的public类,access_flags的值为:0x0001+0x0020=0x0021

### 1.3.2.4 类索引,父类索引,接口索引

访问标志后面是这些索引的信息,其中类索引和父类索引是一个u2类型的数据,接口索引是一组u2类型的数据.

顺序为:类索引+父类索引+接口索引大小+接口索引

### 1.3.2.5 字段表集合

字段表是用于描述类或者接口中声明的变量.字段主要有类级变量和实例级变量,不包括方法内部声明的变量.

![img](7.png)

其中access_flag和类中的访问标志相似.可以设置的值如下:

![img](8.png)

然后name_index和descriptor_index分别代表了简单名称和描述符;

概念:

① 全限定名:类名中的点变成"/",例如:org/da/dad/aa.class

② 简单名称: 没有类型和参数修饰的字段或者方法,inf()简称为inf

③ 描述符: 描述字段的数据类型.基本数据类型通常用一个大写字母表示,对象类型用"L+全限定名"来表示.

![img](9.png)

对于数组类型,一维数组使用[描述,例如int[],用'[I'表示.二维的用'[['表示,例如:Integer[][]用[[I表示.

后续的attribute_count和attribute只有在给字段添加默认值的时候,才会显示.

### 1.3.2.6 方法表集合

字段表后面跟着的是方法表,两者很类似,

![img](10.png)

其中的访问标志选项为:

![img](11.png)

顺序为:方法数量+访问标志+...(结构体)

其中,方法里面的代码在编译成字节码后,会存放在方法属性表里面,对应的key为Code.

### 1.3.2.7 属性表集合

和其他结构不同,属性表不要求有严格的顺序,长度和内容.只需要和已有的属性名不同即可.

java虚拟机定义了21个预定义属性,详情可看书中,暂不一一列举.

对于每一个属性,都会用一个constant_utf8_info属性来表示.

![img](12.png)

其中简要说下Code属性:

code属性是方法里面的代码编译后的字节码:

![img](13.png)

① attribute_name_index :

constant_utf8_info的常量,固定值为"code",表示属性名称.

② attribute_length: 属性长度,为6个字节.

③ max_stack: 操作栈的深度.java虚拟机会根据这个深度来分配.

④ max_locals: 局部变量表所需要的空间.

⑤ code_length ,code: java源文件编译后的字节码指令.

# 1.4 字节码指令

java虚拟机的指令是由一个字节的,代表某种操作含义的数字(操作码)+(0,n)个代表此操作所需的参数(操作数)组成.但是由于java虚拟机的架构是面向操作数栈而不是面向寄存器的,因此一般都是只有一个操作码组成.

一个字节的操作码长度为:0-255.

因此java虚拟机的执行基础模型为:![img](14.png)

## 1.4.1 字节码与数据类型

 在java虚拟机指令集中,大多都会携带其操作所需的数据类型,但是并非所有的数据类型都会有对于的指令.会有一些单独的指令在必要的时候,将不支持的类型转化为支持的.大体上可划分为9个指令.

## 1.4.2 加载和存储指令

主要将数据在栈帧中的局部变量表和操作数栈之间传输,主要包括:

① 将一个局部变量加载到操作栈:iload等;

② 将一个数值从操作栈存储到局部变量表: istore等

③ 将一个常量加载到操作栈:bipush

## 1.4.3 运算指令

用于对操作数栈上的数值进行某种运算,然后把结果存到栈顶.

注意:java虚拟机没有操作byte,boolean,short,char的指令,最后都会转化为int指令来特殊操作.

## 1.4.4 类型转化指令

![img](15.png)

java数据类型及其大小,在进行转化的时候,是默认支持小范围向大范围转化的.而在大范围向小范围转化时,需要进行强制转化.

## 1.4.5 对象的创建以及访问指令

数组和类实例用到了不同的创建指令.![img](16.png)

## 1.4.6 操作数栈管理指令

和操作普通的堆栈一样,java虚拟机提供了用于直接操作操作数栈的指令:

① 出栈: pop,pop2

② 复制栈顶数值,并重新压入栈顶,dup,dup2

③ 将栈最顶端的2个值互换,swap

## 1.4.7 控制转移指令

有条件或者无条件的修改寄存器的值:

![img](17.png)

## 1.4.8 方法调用和返回指令![img](18.png)

![img](19.png)

## 1.4.9 异常处理指令

显示抛出异常的语句,是由athrow指令实现,并且除了显示跑出异常,java虚拟机也会有一些指令进行异常检测.

处理异常(catch语句),没有字节码指令,这部分功能是由异常表来完成

## 1.4.10 同步指令

包括2种同步方式,都是由管程(Monitor)支持:

① 方法级同步:

不通过字节码来操作,是在方法的调用和返回中实现.

流程是:从常量池中取出acc_synchronized得知是否为同步方法,如果是,当前线程则会持有管程,方法执行完后,释放管程.同一个管程只能在一个线程中存在.

② 同步一段指令集序列:

是由java语言的synchronized语句块表示,这个关键字由2个指令支持:monitorenter和monitorexit

例如:

以下代码的字节码为:

![img](20.png)

![img](21.png)

 

 