---
title: jvm之内存模型
date: 2019-03-17 11:47:16
tags: java内存模型
categories:
- jvm
- 内存模型 
---



![img](1.png)

![img](4.png)

<!-- more -->

屏幕剪辑的捕获时间: 2019/3/16 10:56

注:

线程共享数据区:虚拟机栈,本地方法栈,程序计数器.

线程隔离数据区:方法区,堆,执行引擎,本地库接口.

# 简介:

由于java将内存的管理交给了虚拟机,了解内存结构,有利于排查内存溢出和泄露问题.

jdk1.8之后,hotspot的jvm:

java整个进程占用的内存： 
- 堆内存 
- metaspace(堆内) JDK8使用metaspace来替代了permsize:永久代大小 
- 堆外内存使用 
- 线程栈空间

# jvm运行时的数据区域:

## 程序计数器:

\1.    一块很小的内存区域,主要作用是当前线程所执行字节码的行号指示器.字节码解释工作是,根据改变程序计数器的值来选取下一条所执行的字节码指令.例如:分支,循环,跳转,异常处理.因为jvm多线程是通过线程轮流切换来实现的,因此程序计数器是线程私有的.

\2.    如果是正在执行java方法,此区域存储的是正在执行的虚拟机的字节码指令.如果是native方法,此区域为undefined.程序计数器是唯一一片不会出现outofmemoryerror的区域.

## java虚拟机栈

\1.      描述的是方法的执行的内存模型,每一个方法的执行都会创建一个栈桢,用于存储局部变量表,操作数栈,动态链接,方法出口信息.

\2.      局部变量表就是平常所说的栈,存储着编译期可知的基本数据类型,对象引用,returnAddress类型.基本单位是32个字节的slot,所需的空间在编译期就可以确定.常出现的异常:stackOverFlowError:请求的栈深度大于所允许的深度.OutMemoryError:虚拟机栈允许动态扩展的情况下,无法申请到足够的内存.

## 本地方法栈

和虚拟机栈的区别是:

虚拟机栈是为java方法提供服务,而本地方法栈则是为了native方法提供服务.

## java堆(重点)

\1.    是java虚拟机所管理的最大的一块内存区域.被所有线程共享.唯一目的是存放对象的实例.按照java虚拟机规范:堆中存放着所有的对象实例和数组信息.后续技术更加成熟也有稍微变化的地方.

\2.    java堆是垃圾收集器管理的主要区域.因此称为GC堆.按照内存回收方面看,可以分为新生代和老年代.永久代在哪?看下面的方法区.0.0

\3.    java堆可以存放在不连续的内存空间,只要是逻辑上连续即可.当无法分配更多的实例时,会抛出OutOfMemoryError.

## 方法区

\1.    主要是存放被虚拟机加载的类的信息,常量,静态变量,编译后的代码.

\2.    HotSpot虚拟机的设计团队选择了将GC分代管理扩展到了方法区,因此方法区就成了GC分代所说的永久代.这个区域很少有垃圾回收行为存在,但是也需要常量的回收和类型的卸载.不过次区域的回收,依旧是难点.

### 运行时的常量池

\1.    运行期的常量池是方法区的一部分,用于存放编译期生成的字面量和符号引用.

\2.    需要注意的是和局部变量表的局别.同样是存储编译期的数据,不过一个是方法的参数,方法内定义的变量.另一个是存储字面量的常量.

## 直接内存

直接内存不是jvm的内存.是介于本地方法栈中的native方法,与java堆之间的一种机器中的内存.主要是在native方法进行io流的时候进行缓存数据的区域.

# 对象的访问

在了解了虚拟机运行时候的数据区域后,下面来看下是如何进行对象访问的.

例如: Object obj = new Object();

假设这块方法出现在方法体中,其中Object obj会映射到虚拟机栈的栈桢的局部变量表中的reference类型. new Object()则会映射到java堆中.另外java堆中还必须能够查到次对象类型的数据(对象的类型,父类,实现的接口,方法),这些数据存放在方法区.其中reference方法是如何定位到java堆中的?主要有2种方式:

\1.    句柄池访问:

 

![img](2.png)

屏幕剪辑的捕获时间: 2019/3/16 12:38

在java堆中划分出一块内存作为句柄池,reference存储的是句柄池的地址.句柄池内存储着对象实例的数据和对象类型的数据.

主要优点是:对象进行移动时,只需要改变句柄池中的对象实例信息.

\2.    直接指针访问方式

 

![img](3.png)

屏幕剪辑的捕获时间: 2019/3/16 12:41

reference存储的是对象实例的数据,这是就要考虑如何放置对象类型的数据的地址.主要优点是节省了一次指针的定位,速度更快.sun 的hotspot所用的虚拟机主要是采用此方案.

# OOM异常

## java堆溢出

通过-Xms指定最小值,-Xmx指定最大值

提示是java heap space,查看对象信息,确定是否是要用的,如果对象必须要或者,则是内存溢出,此时加大虚拟机内存.如果对象不必须活着,则是内心泄露,此时定位到对象点,进行处理.

## 虚拟机栈和本地方法栈溢出

通过-Xss128k,表示指定大小为128k,主要有2种异常

\1.    线程请求的深度大于虚拟机允许的最大深度:Stack OverflowError.

\2.    虚拟机在扩展栈时,无法请求到足够的内存:OOM

## 运行时常量池溢出

方法区内存,指定大小和方法区一致.提示信息是:PermGen space .

## 方法区溢出(1.8之后移除)

通过-XX:PerSize和-XX:MaxPermSize指定大小,提示信息是:PermGen space ,方法区主要存储的是Class的信息,如类名,修饰符,常量池,字段描述,方法描述等.(1.8之后已经失效)

### 元空间

在jdk1.8之后,hotspot对jvm架构进行了改变,将类的元数据放在了本地内存里面,静态变量和常量池放在了java堆中,移除了永久代,元数据是描述数据之间的关系的数据,其表现形式是1.5之后的注解,1.5之前的xml文件.由于在本地内存中,可以避免两个项目引用了同样的jar包,会出现大量的相同类信息引发的oom异常.避免了与老年代的资源竞争.

可用-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定元数据大小

## 本机直接内存溢出

通过-XX:MaxDirectMemorySize指定大小,仅是抛出OOM溢出.



